(function () {
	'use strict';

	/** Virtual DOM Node */
	function VNode() {}

	/** Global options
	 *	@public
	 *	@namespace options {Object}
	 */
	var options = {

		/** If `true`, `prop` changes trigger synchronous component updates.
	  *	@name syncComponentUpdates
	  *	@type Boolean
	  *	@default true
	  */
		//syncComponentUpdates: true,

		/** Processes all created VNodes.
	  *	@param {VNode} vnode	A newly-created VNode to normalize/process
	  */
		//vnode(vnode) { }

		/** Hook invoked after a component is mounted. */
		// afterMount(component) { }

		/** Hook invoked after the DOM is updated with a component's latest render. */
		// afterUpdate(component) { }

		/** Hook invoked immediately before a component is unmounted. */
		// beforeUnmount(component) { }
	};

	var stack = [];

	var EMPTY_CHILDREN = [];

	/** JSX/hyperscript reviver
	*	Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0
	 *	@see http://jasonformat.com/wtf-is-jsx
	 *	@public
	 */
	function h(nodeName, attributes) {
		var children = EMPTY_CHILDREN,
		    lastSimple,
		    child,
		    simple,
		    i;
		for (i = arguments.length; i-- > 2;) {
			stack.push(arguments[i]);
		}
		if (attributes && attributes.children != null) {
			if (!stack.length) stack.push(attributes.children);
			delete attributes.children;
		}
		while (stack.length) {
			if ((child = stack.pop()) && child.pop !== undefined) {
				for (i = child.length; i--;) {
					stack.push(child[i]);
				}
			} else {
				if (typeof child === 'boolean') child = null;

				if (simple = typeof nodeName !== 'function') {
					if (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;
				}

				if (simple && lastSimple) {
					children[children.length - 1] += child;
				} else if (children === EMPTY_CHILDREN) {
					children = [child];
				} else {
					children.push(child);
				}

				lastSimple = simple;
			}
		}

		var p = new VNode();
		p.nodeName = nodeName;
		p.children = children;
		p.attributes = attributes == null ? undefined : attributes;
		p.key = attributes == null ? undefined : attributes.key;

		return p;
	}

	/** Copy own-properties from `props` onto `obj`.
	 *	@returns obj
	 *	@private
	 */
	function extend(obj, props) {
	  for (var i in props) {
	    obj[i] = props[i];
	  }return obj;
	}

	/** Call a function asynchronously, as soon as possible.
	 *	@param {Function} callback
	 */
	var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

	// DOM properties that should NOT have "px" added when numeric
	var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

	/** Managed queue of dirty components to be re-rendered */

	var items = [];

	function enqueueRender(component) {
		if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
			(defer)(rerender);
		}
	}

	function rerender() {
		var p,
		    list = items;
		items = [];
		while (p = list.pop()) {
			if (p._dirty) renderComponent(p);
		}
	}

	/** Check if two nodes are equivalent.
	 *	@param {Element} node
	 *	@param {VNode} vnode
	 *	@private
	 */
	function isSameNodeType(node, vnode, hydrating) {
		if (typeof vnode === 'string' || typeof vnode === 'number') {
			return node.splitText !== undefined;
		}
		if (typeof vnode.nodeName === 'string') {
			return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
		}
		return hydrating || node._componentConstructor === vnode.nodeName;
	}

	/** Check if an Element has a given normalized name.
	*	@param {Element} node
	*	@param {String} nodeName
	 */
	function isNamedNode(node, nodeName) {
		return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
	}

	/**
	 * Reconstruct Component-style `props` from a VNode.
	 * Ensures default/fallback values from `defaultProps`:
	 * Own-properties of `defaultProps` not present in `vnode.attributes` are added.
	 * @param {VNode} vnode
	 * @returns {Object} props
	 */
	function getNodeProps(vnode) {
		var props = extend({}, vnode.attributes);
		props.children = vnode.children;

		var defaultProps = vnode.nodeName.defaultProps;
		if (defaultProps !== undefined) {
			for (var i in defaultProps) {
				if (props[i] === undefined) {
					props[i] = defaultProps[i];
				}
			}
		}

		return props;
	}

	/** Create an element with the given nodeName.
	 *	@param {String} nodeName
	 *	@param {Boolean} [isSvg=false]	If `true`, creates an element within the SVG namespace.
	 *	@returns {Element} node
	 */
	function createNode(nodeName, isSvg) {
		var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
		node.normalizedNodeName = nodeName;
		return node;
	}

	/** Remove a child node from its parent if attached.
	 *	@param {Element} node		The node to remove
	 */
	function removeNode(node) {
		var parentNode = node.parentNode;
		if (parentNode) parentNode.removeChild(node);
	}

	/** Set a named attribute on the given Node, with special behavior for some names and event handlers.
	 *	If `value` is `null`, the attribute/handler will be removed.
	 *	@param {Element} node	An element to mutate
	 *	@param {string} name	The name/key to set, such as an event or attribute name
	 *	@param {any} old	The last value that was set for this name/node pair
	 *	@param {any} value	An attribute value, such as a function to be used as an event handler
	 *	@param {Boolean} isSvg	Are we currently diffing inside an svg?
	 *	@private
	 */
	function setAccessor(node, name, old, value, isSvg) {
		if (name === 'className') name = 'class';

		if (name === 'key') ; else if (name === 'ref') {
			if (old) old(null);
			if (value) value(node);
		} else if (name === 'class' && !isSvg) {
			node.className = value || '';
		} else if (name === 'style') {
			if (!value || typeof value === 'string' || typeof old === 'string') {
				node.style.cssText = value || '';
			}
			if (value && typeof value === 'object') {
				if (typeof old !== 'string') {
					for (var i in old) {
						if (!(i in value)) node.style[i] = '';
					}
				}
				for (var i in value) {
					node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
				}
			}
		} else if (name === 'dangerouslySetInnerHTML') {
			if (value) node.innerHTML = value.__html || '';
		} else if (name[0] == 'o' && name[1] == 'n') {
			var useCapture = name !== (name = name.replace(/Capture$/, ''));
			name = name.toLowerCase().substring(2);
			if (value) {
				if (!old) node.addEventListener(name, eventProxy, useCapture);
			} else {
				node.removeEventListener(name, eventProxy, useCapture);
			}
			(node._listeners || (node._listeners = {}))[name] = value;
		} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
			setProperty(node, name, value == null ? '' : value);
			if (value == null || value === false) node.removeAttribute(name);
		} else {
			var ns = isSvg && name !== (name = name.replace(/^xlink\:?/, ''));
			if (value == null || value === false) {
				if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);
			} else if (typeof value !== 'function') {
				if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);
			}
		}
	}

	/** Attempt to set a DOM property to the given value.
	 *	IE & FF throw for certain property-value combinations.
	 */
	function setProperty(node, name, value) {
		try {
			node[name] = value;
		} catch (e) {}
	}

	/** Proxy an event to hooked event handlers
	 *	@private
	 */
	function eventProxy(e) {
		return this._listeners[e.type](e);
	}

	/** Queue of components that have been mounted and are awaiting componentDidMount */
	var mounts = [];

	/** Diff recursion count, used to track the end of the diff cycle. */
	var diffLevel = 0;

	/** Global flag indicating if the diff is currently within an SVG */
	var isSvgMode = false;

	/** Global flag indicating if the diff is performing hydration */
	var hydrating = false;

	/** Invoke queued componentDidMount lifecycle methods */
	function flushMounts() {
		var c;
		while (c = mounts.pop()) {
			if (c.componentDidMount) c.componentDidMount();
		}
	}

	/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.
	 *	@param {Element} [dom=null]		A DOM node to mutate into the shape of the `vnode`
	 *	@param {VNode} vnode			A VNode (with descendants forming a tree) representing the desired DOM structure
	 *	@returns {Element} dom			The created/mutated element
	 *	@private
	 */
	function diff(dom, vnode, context, mountAll, parent, componentRoot) {
		// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)
		if (!diffLevel++) {
			// when first starting the diff, check if we're diffing an SVG or within an SVG
			isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

			// hydration is indicated by the existing element to be diffed not having a prop cache
			hydrating = dom != null && !('__preactattr_' in dom);
		}

		var ret = idiff(dom, vnode, context, mountAll, componentRoot);

		// append the element if its a new parent
		if (parent && ret.parentNode !== parent) parent.appendChild(ret);

		// diffLevel being reduced to 0 means we're exiting the diff
		if (! --diffLevel) {
			hydrating = false;
			// invoke queued componentDidMount lifecycle methods
			if (!componentRoot) flushMounts();
		}

		return ret;
	}

	/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */
	function idiff(dom, vnode, context, mountAll, componentRoot) {
		var out = dom,
		    prevSvgMode = isSvgMode;

		// empty values (null, undefined, booleans) render as empty Text nodes
		if (vnode == null || typeof vnode === 'boolean') vnode = '';

		// Fast case: Strings & Numbers create/update Text nodes.
		if (typeof vnode === 'string' || typeof vnode === 'number') {

			// update if it's already a Text node:
			if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
				/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */
				if (dom.nodeValue != vnode) {
					dom.nodeValue = vnode;
				}
			} else {
				// it wasn't a Text node: replace it with one and recycle the old Element
				out = document.createTextNode(vnode);
				if (dom) {
					if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
					recollectNodeTree(dom, true);
				}
			}

			out['__preactattr_'] = true;

			return out;
		}

		// If the VNode represents a Component, perform a component diff:
		var vnodeName = vnode.nodeName;
		if (typeof vnodeName === 'function') {
			return buildComponentFromVNode(dom, vnode, context, mountAll);
		}

		// Tracks entering and exiting SVG namespace when descending through the tree.
		isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

		// If there's no existing element or it's the wrong type, create a new one:
		vnodeName = String(vnodeName);
		if (!dom || !isNamedNode(dom, vnodeName)) {
			out = createNode(vnodeName, isSvgMode);

			if (dom) {
				// move children into the replacement node
				while (dom.firstChild) {
					out.appendChild(dom.firstChild);
				} // if the previous Element was mounted into the DOM, replace it inline
				if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

				// recycle the old element (skips non-Element node types)
				recollectNodeTree(dom, true);
			}
		}

		var fc = out.firstChild,
		    props = out['__preactattr_'],
		    vchildren = vnode.children;

		if (props == null) {
			props = out['__preactattr_'] = {};
			for (var a = out.attributes, i = a.length; i--;) {
				props[a[i].name] = a[i].value;
			}
		}

		// Optimization: fast-path for elements containing a single TextNode:
		if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
			if (fc.nodeValue != vchildren[0]) {
				fc.nodeValue = vchildren[0];
			}
		}
		// otherwise, if there are existing or new children, diff them:
		else if (vchildren && vchildren.length || fc != null) {
				innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
			}

		// Apply attributes/props from VNode to the DOM Element:
		diffAttributes(out, vnode.attributes, props);

		// restore previous SVG mode: (in case we're exiting an SVG namespace)
		isSvgMode = prevSvgMode;

		return out;
	}

	/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.
	 *	@param {Element} dom			Element whose children should be compared & mutated
	 *	@param {Array} vchildren		Array of VNodes to compare to `dom.childNodes`
	 *	@param {Object} context			Implicitly descendant context object (from most recent `getChildContext()`)
	 *	@param {Boolean} mountAll
	 *	@param {Boolean} isHydrating	If `true`, consumes externally created elements similar to hydration
	 */
	function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
		var originalChildren = dom.childNodes,
		    children = [],
		    keyed = {},
		    keyedLen = 0,
		    min = 0,
		    len = originalChildren.length,
		    childrenLen = 0,
		    vlen = vchildren ? vchildren.length : 0,
		    j,
		    c,
		    f,
		    vchild,
		    child;

		// Build up a map of keyed children and an Array of unkeyed children:
		if (len !== 0) {
			for (var i = 0; i < len; i++) {
				var _child = originalChildren[i],
				    props = _child['__preactattr_'],
				    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
				if (key != null) {
					keyedLen++;
					keyed[key] = _child;
				} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
					children[childrenLen++] = _child;
				}
			}
		}

		if (vlen !== 0) {
			for (var i = 0; i < vlen; i++) {
				vchild = vchildren[i];
				child = null;

				// attempt to find a node based on key matching
				var key = vchild.key;
				if (key != null) {
					if (keyedLen && keyed[key] !== undefined) {
						child = keyed[key];
						keyed[key] = undefined;
						keyedLen--;
					}
				}
				// attempt to pluck a node of the same type from the existing children
				else if (!child && min < childrenLen) {
						for (j = min; j < childrenLen; j++) {
							if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
								child = c;
								children[j] = undefined;
								if (j === childrenLen - 1) childrenLen--;
								if (j === min) min++;
								break;
							}
						}
					}

				// morph the matched/found/created DOM child to match vchild (deep)
				child = idiff(child, vchild, context, mountAll);

				f = originalChildren[i];
				if (child && child !== dom && child !== f) {
					if (f == null) {
						dom.appendChild(child);
					} else if (child === f.nextSibling) {
						removeNode(f);
					} else {
						dom.insertBefore(child, f);
					}
				}
			}
		}

		// remove unused keyed children:
		if (keyedLen) {
			for (var i in keyed) {
				if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
			}
		}

		// remove orphaned unkeyed children:
		while (min <= childrenLen) {
			if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
		}
	}

	/** Recursively recycle (or just unmount) a node and its descendants.
	 *	@param {Node} node						DOM node to start unmount/removal from
	 *	@param {Boolean} [unmountOnly=false]	If `true`, only triggers unmount lifecycle, skips removal
	 */
	function recollectNodeTree(node, unmountOnly) {
		var component = node._component;
		if (component) {
			// if node is owned by a Component, unmount that component (ends up recursing back here)
			unmountComponent(component);
		} else {
			// If the node's VNode had a ref function, invoke it with null here.
			// (this is part of the React spec, and smart for unsetting references)
			if (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);

			if (unmountOnly === false || node['__preactattr_'] == null) {
				removeNode(node);
			}

			removeChildren(node);
		}
	}

	/** Recollect/unmount all children.
	 *	- we use .lastChild here because it causes less reflow than .firstChild
	 *	- it's also cheaper than accessing the .childNodes Live NodeList
	 */
	function removeChildren(node) {
		node = node.lastChild;
		while (node) {
			var next = node.previousSibling;
			recollectNodeTree(node, true);
			node = next;
		}
	}

	/** Apply differences in attributes from a VNode to the given DOM Element.
	 *	@param {Element} dom		Element with attributes to diff `attrs` against
	 *	@param {Object} attrs		The desired end-state key-value attribute pairs
	 *	@param {Object} old			Current/previous attributes (from previous VNode or element's prop cache)
	 */
	function diffAttributes(dom, attrs, old) {
		var name;

		// remove attributes no longer present on the vnode by setting them to undefined
		for (name in old) {
			if (!(attrs && attrs[name] != null) && old[name] != null) {
				setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
			}
		}

		// add new & update changed attributes
		for (name in attrs) {
			if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
				setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
			}
		}
	}

	/** Retains a pool of Components for re-use, keyed on component name.
	 *	Note: since component names are not unique or even necessarily available, these are primarily a form of sharding.
	 *	@private
	 */
	var components = {};

	/** Reclaim a component for later re-use by the recycler. */
	function collectComponent(component) {
		var name = component.constructor.name;
		(components[name] || (components[name] = [])).push(component);
	}

	/** Create a component. Normalizes differences between PFC's and classful Components. */
	function createComponent(Ctor, props, context) {
		var list = components[Ctor.name],
		    inst;

		if (Ctor.prototype && Ctor.prototype.render) {
			inst = new Ctor(props, context);
			Component.call(inst, props, context);
		} else {
			inst = new Component(props, context);
			inst.constructor = Ctor;
			inst.render = doRender;
		}

		if (list) {
			for (var i = list.length; i--;) {
				if (list[i].constructor === Ctor) {
					inst.nextBase = list[i].nextBase;
					list.splice(i, 1);
					break;
				}
			}
		}
		return inst;
	}

	/** The `.render()` method for a PFC backing instance. */
	function doRender(props, state, context) {
		return this.constructor(props, context);
	}

	/** Set a component's `props` (generally derived from JSX attributes).
	 *	@param {Object} props
	 *	@param {Object} [opts]
	 *	@param {boolean} [opts.renderSync=false]	If `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.
	 *	@param {boolean} [opts.render=true]			If `false`, no render will be triggered.
	 */
	function setComponentProps(component, props, opts, context, mountAll) {
		if (component._disable) return;
		component._disable = true;

		if (component.__ref = props.ref) delete props.ref;
		if (component.__key = props.key) delete props.key;

		if (!component.base || mountAll) {
			if (component.componentWillMount) component.componentWillMount();
		} else if (component.componentWillReceiveProps) {
			component.componentWillReceiveProps(props, context);
		}

		if (context && context !== component.context) {
			if (!component.prevContext) component.prevContext = component.context;
			component.context = context;
		}

		if (!component.prevProps) component.prevProps = component.props;
		component.props = props;

		component._disable = false;

		if (opts !== 0) {
			if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
				renderComponent(component, 1, mountAll);
			} else {
				enqueueRender(component);
			}
		}

		if (component.__ref) component.__ref(component);
	}

	/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.
	 *	@param {Component} component
	 *	@param {Object} [opts]
	 *	@param {boolean} [opts.build=false]		If `true`, component will build and store a DOM node if not already associated with one.
	 *	@private
	 */
	function renderComponent(component, opts, mountAll, isChild) {
		if (component._disable) return;

		var props = component.props,
		    state = component.state,
		    context = component.context,
		    previousProps = component.prevProps || props,
		    previousState = component.prevState || state,
		    previousContext = component.prevContext || context,
		    isUpdate = component.base,
		    nextBase = component.nextBase,
		    initialBase = isUpdate || nextBase,
		    initialChildComponent = component._component,
		    skip = false,
		    rendered,
		    inst,
		    cbase;

		// if updating
		if (isUpdate) {
			component.props = previousProps;
			component.state = previousState;
			component.context = previousContext;
			if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
				skip = true;
			} else if (component.componentWillUpdate) {
				component.componentWillUpdate(props, state, context);
			}
			component.props = props;
			component.state = state;
			component.context = context;
		}

		component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
		component._dirty = false;

		if (!skip) {
			rendered = component.render(props, state, context);

			// context to pass to the child, can be updated via (grand-)parent component
			if (component.getChildContext) {
				context = extend(extend({}, context), component.getChildContext());
			}

			var childComponent = rendered && rendered.nodeName,
			    toUnmount,
			    base;

			if (typeof childComponent === 'function') {
				// set up high order component link

				var childProps = getNodeProps(rendered);
				inst = initialChildComponent;

				if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
					setComponentProps(inst, childProps, 1, context, false);
				} else {
					toUnmount = inst;

					component._component = inst = createComponent(childComponent, childProps, context);
					inst.nextBase = inst.nextBase || nextBase;
					inst._parentComponent = component;
					setComponentProps(inst, childProps, 0, context, false);
					renderComponent(inst, 1, mountAll, true);
				}

				base = inst.base;
			} else {
				cbase = initialBase;

				// destroy high order component link
				toUnmount = initialChildComponent;
				if (toUnmount) {
					cbase = component._component = null;
				}

				if (initialBase || opts === 1) {
					if (cbase) cbase._component = null;
					base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
				}
			}

			if (initialBase && base !== initialBase && inst !== initialChildComponent) {
				var baseParent = initialBase.parentNode;
				if (baseParent && base !== baseParent) {
					baseParent.replaceChild(base, initialBase);

					if (!toUnmount) {
						initialBase._component = null;
						recollectNodeTree(initialBase, false);
					}
				}
			}

			if (toUnmount) {
				unmountComponent(toUnmount);
			}

			component.base = base;
			if (base && !isChild) {
				var componentRef = component,
				    t = component;
				while (t = t._parentComponent) {
					(componentRef = t).base = base;
				}
				base._component = componentRef;
				base._componentConstructor = componentRef.constructor;
			}
		}

		if (!isUpdate || mountAll) {
			mounts.unshift(component);
		} else if (!skip) {
			// Ensure that pending componentDidMount() hooks of child components
			// are called before the componentDidUpdate() hook in the parent.
			// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750
			// flushMounts();

			if (component.componentDidUpdate) {
				component.componentDidUpdate(previousProps, previousState, previousContext);
			}
		}

		if (component._renderCallbacks != null) {
			while (component._renderCallbacks.length) {
				component._renderCallbacks.pop().call(component);
			}
		}

		if (!diffLevel && !isChild) flushMounts();
	}

	/** Apply the Component referenced by a VNode to the DOM.
	 *	@param {Element} dom	The DOM node to mutate
	 *	@param {VNode} vnode	A Component-referencing VNode
	 *	@returns {Element} dom	The created/mutated element
	 *	@private
	 */
	function buildComponentFromVNode(dom, vnode, context, mountAll) {
		var c = dom && dom._component,
		    originalComponent = c,
		    oldDom = dom,
		    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
		    isOwner = isDirectOwner,
		    props = getNodeProps(vnode);
		while (c && !isOwner && (c = c._parentComponent)) {
			isOwner = c.constructor === vnode.nodeName;
		}

		if (c && isOwner && (!mountAll || c._component)) {
			setComponentProps(c, props, 3, context, mountAll);
			dom = c.base;
		} else {
			if (originalComponent && !isDirectOwner) {
				unmountComponent(originalComponent);
				dom = oldDom = null;
			}

			c = createComponent(vnode.nodeName, props, context);
			if (dom && !c.nextBase) {
				c.nextBase = dom;
				// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:
				oldDom = null;
			}
			setComponentProps(c, props, 1, context, mountAll);
			dom = c.base;

			if (oldDom && dom !== oldDom) {
				oldDom._component = null;
				recollectNodeTree(oldDom, false);
			}
		}

		return dom;
	}

	/** Remove a component from the DOM and recycle it.
	 *	@param {Component} component	The Component instance to unmount
	 *	@private
	 */
	function unmountComponent(component) {

		var base = component.base;

		component._disable = true;

		if (component.componentWillUnmount) component.componentWillUnmount();

		component.base = null;

		// recursively tear down & recollect high-order component children:
		var inner = component._component;
		if (inner) {
			unmountComponent(inner);
		} else if (base) {
			if (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);

			component.nextBase = base;

			removeNode(base);
			collectComponent(component);

			removeChildren(base);
		}

		if (component.__ref) component.__ref(null);
	}

	/** Base Component class.
	 *	Provides `setState()` and `forceUpdate()`, which trigger rendering.
	 *	@public
	 *
	 *	@example
	 *	class MyFoo extends Component {
	 *		render(props, state) {
	 *			return <div />;
	 *		}
	 *	}
	 */
	function Component(props, context) {
		this._dirty = true;

		/** @public
	  *	@type {object}
	  */
		this.context = context;

		/** @public
	  *	@type {object}
	  */
		this.props = props;

		/** @public
	  *	@type {object}
	  */
		this.state = this.state || {};
	}

	extend(Component.prototype, {

		/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.
	  *	@param {object} nextProps
	  *	@param {object} nextState
	  *	@param {object} nextContext
	  *	@returns {Boolean} should the component re-render
	  *	@name shouldComponentUpdate
	  *	@function
	  */

		/** Update component state by copying properties from `state` to `this.state`.
	  *	@param {object} state		A hash of state properties to update with new values
	  *	@param {function} callback	A function to be called once component state is updated
	  */
		setState: function setState(state, callback) {
			var s = this.state;
			if (!this.prevState) this.prevState = extend({}, s);
			extend(s, typeof state === 'function' ? state(s, this.props) : state);
			if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
			enqueueRender(this);
		},


		/** Immediately perform a synchronous re-render of the component.
	  *	@param {function} callback		A function to be called after component is re-rendered.
	  *	@private
	  */
		forceUpdate: function forceUpdate(callback) {
			if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);
			renderComponent(this, 2);
		},


		/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
	  *	Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
	  *	@param {object} props		Props (eg: JSX attributes) received from parent element/component
	  *	@param {object} state		The component's current state
	  *	@param {object} context		Context object (if a parent component has provided context)
	  *	@returns VNode
	  */
		render: function render() {}
	});

	/** Render JSX into a `parent` Element.
	 *	@param {VNode} vnode		A (JSX) VNode to render
	 *	@param {Element} parent		DOM element to render into
	 *	@param {Element} [merge]	Attempt to re-use an existing DOM tree rooted at `merge`
	 *	@public
	 *
	 *	@example
	 *	// render a div into <body>:
	 *	render(<div id="hello">hello!</div>, document.body);
	 *
	 *	@example
	 *	// render a "Thing" component into #foo:
	 *	const Thing = ({ name }) => <span>{ name }</span>;
	 *	render(<Thing name="one" />, document.querySelector('#foo'));
	 */
	function render(vnode, parent, merge) {
	  return diff(merge, vnode, {}, false, parent, false);
	}

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var capitalizeString_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = capitalizeString;
	function capitalizeString(str) {
	  return str.charAt(0).toUpperCase() + str.slice(1);
	}
	module.exports = exports["default"];
	});

	var capitalizeString = unwrapExports(capitalizeString_1);

	var capitalizeString$1 = /*#__PURE__*/Object.freeze({
		default: capitalizeString,
		__moduleExports: capitalizeString_1
	});

	var _capitalizeString = ( capitalizeString$1 && capitalizeString ) || capitalizeString$1;

	var prefixProperty_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prefixProperty;



	var _capitalizeString2 = _interopRequireDefault(_capitalizeString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function prefixProperty(prefixProperties, property, style) {
	  if (prefixProperties.hasOwnProperty(property)) {
	    var requiredPrefixes = prefixProperties[property];
	    for (var i = 0, len = requiredPrefixes.length; i < len; ++i) {
	      style[requiredPrefixes[i] + (0, _capitalizeString2.default)(property)] = style[property];
	    }
	  }
	}
	module.exports = exports['default'];
	});

	var prefixProperty = unwrapExports(prefixProperty_1);

	var prefixProperty$1 = /*#__PURE__*/Object.freeze({
		default: prefixProperty,
		__moduleExports: prefixProperty_1
	});

	var prefixValue_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = prefixValue;
	function prefixValue(plugins, property, value, style, metaData) {
	  for (var i = 0, len = plugins.length; i < len; ++i) {
	    var processedValue = plugins[i](property, value, style, metaData);

	    // we can stop processing if a value is returned
	    // as all plugin criteria are unique
	    if (processedValue) {
	      return processedValue;
	    }
	  }
	}
	module.exports = exports["default"];
	});

	var prefixValue = unwrapExports(prefixValue_1);

	var prefixValue$1 = /*#__PURE__*/Object.freeze({
		default: prefixValue,
		__moduleExports: prefixValue_1
	});

	var addNewValuesOnly_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = addNewValuesOnly;
	function addIfNew(list, value) {
	  if (list.indexOf(value) === -1) {
	    list.push(value);
	  }
	}

	function addNewValuesOnly(list, values) {
	  if (Array.isArray(values)) {
	    for (var i = 0, len = values.length; i < len; ++i) {
	      addIfNew(list, values[i]);
	    }
	  } else {
	    addIfNew(list, values);
	  }
	}
	module.exports = exports["default"];
	});

	var addNewValuesOnly = unwrapExports(addNewValuesOnly_1);

	var addNewValuesOnly$1 = /*#__PURE__*/Object.freeze({
		default: addNewValuesOnly,
		__moduleExports: addNewValuesOnly_1
	});

	var isObject_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isObject;
	function isObject(value) {
	  return value instanceof Object && !Array.isArray(value);
	}
	module.exports = exports["default"];
	});

	var isObject = unwrapExports(isObject_1);

	var isObject$1 = /*#__PURE__*/Object.freeze({
		default: isObject,
		__moduleExports: isObject_1
	});

	var _prefixProperty = ( prefixProperty$1 && prefixProperty ) || prefixProperty$1;

	var _prefixValue = ( prefixValue$1 && prefixValue ) || prefixValue$1;

	var _addNewValuesOnly = ( addNewValuesOnly$1 && addNewValuesOnly ) || addNewValuesOnly$1;

	var _isObject = ( isObject$1 && isObject ) || isObject$1;

	var createPrefixer_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = createPrefixer;



	var _prefixProperty2 = _interopRequireDefault(_prefixProperty);



	var _prefixValue2 = _interopRequireDefault(_prefixValue);



	var _addNewValuesOnly2 = _interopRequireDefault(_addNewValuesOnly);



	var _isObject2 = _interopRequireDefault(_isObject);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function createPrefixer(_ref) {
	  var prefixMap = _ref.prefixMap,
	      plugins = _ref.plugins;

	  function prefixAll(style) {
	    for (var property in style) {
	      var value = style[property];

	      // handle nested objects
	      if ((0, _isObject2.default)(value)) {
	        style[property] = prefixAll(value);
	        // handle array values
	      } else if (Array.isArray(value)) {
	        var combinedValue = [];

	        for (var i = 0, len = value.length; i < len; ++i) {
	          var processedValue = (0, _prefixValue2.default)(plugins, property, value[i], style, prefixMap);
	          (0, _addNewValuesOnly2.default)(combinedValue, processedValue || value[i]);
	        }

	        // only modify the value if it was touched
	        // by any plugin to prevent unnecessary mutations
	        if (combinedValue.length > 0) {
	          style[property] = combinedValue;
	        }
	      } else {
	        var _processedValue = (0, _prefixValue2.default)(plugins, property, value, style, prefixMap);

	        // only modify the value if it was touched
	        // by any plugin to prevent unnecessary mutations
	        if (_processedValue) {
	          style[property] = _processedValue;
	        }

	        (0, _prefixProperty2.default)(prefixMap, property, style);
	      }
	    }

	    return style;
	  }

	  return prefixAll;
	}
	module.exports = exports['default'];
	});

	var createPrefixer = unwrapExports(createPrefixer_1);

	var createPrefixer$1 = /*#__PURE__*/Object.freeze({
		default: createPrefixer,
		__moduleExports: createPrefixer_1
	});

	var isPrefixedValue_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isPrefixedValue;
	var regex = /-webkit-|-moz-|-ms-/;

	function isPrefixedValue(value) {
	  return typeof value === 'string' && regex.test(value);
	}
	module.exports = exports['default'];
	});

	var isPrefixedValue = unwrapExports(isPrefixedValue_1);

	var isPrefixedValue$1 = /*#__PURE__*/Object.freeze({
		default: isPrefixedValue,
		__moduleExports: isPrefixedValue_1
	});

	var _isPrefixedValue = ( isPrefixedValue$1 && isPrefixedValue ) || isPrefixedValue$1;

	var calc_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = calc;



	var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var prefixes = ['-webkit-', '-moz-', ''];
	function calc(property, value) {
	  if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && value.indexOf('calc(') > -1) {
	    return prefixes.map(function (prefix) {
	      return value.replace(/calc\(/g, prefix + 'calc(');
	    });
	  }
	}
	module.exports = exports['default'];
	});

	var calc = unwrapExports(calc_1);

	var calc$1 = /*#__PURE__*/Object.freeze({
		default: calc,
		__moduleExports: calc_1
	});

	var crossFade_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = crossFade;



	var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// http://caniuse.com/#search=cross-fade
	var prefixes = ['-webkit-', ''];
	function crossFade(property, value) {
	  if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && value.indexOf('cross-fade(') > -1) {
	    return prefixes.map(function (prefix) {
	      return value.replace(/cross-fade\(/g, prefix + 'cross-fade(');
	    });
	  }
	}
	module.exports = exports['default'];
	});

	var crossFade = unwrapExports(crossFade_1);

	var crossFade$1 = /*#__PURE__*/Object.freeze({
		default: crossFade,
		__moduleExports: crossFade_1
	});

	var cursor_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = cursor;
	var prefixes = ['-webkit-', '-moz-', ''];

	var values = {
	  'zoom-in': true,
	  'zoom-out': true,
	  grab: true,
	  grabbing: true
	};

	function cursor(property, value) {
	  if (property === 'cursor' && values.hasOwnProperty(value)) {
	    return prefixes.map(function (prefix) {
	      return prefix + value;
	    });
	  }
	}
	module.exports = exports['default'];
	});

	var cursor = unwrapExports(cursor_1);

	var cursor$1 = /*#__PURE__*/Object.freeze({
		default: cursor,
		__moduleExports: cursor_1
	});

	var filter_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = filter;



	var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// http://caniuse.com/#feat=css-filter-function
	var prefixes = ['-webkit-', ''];
	function filter(property, value) {
	  if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && value.indexOf('filter(') > -1) {
	    return prefixes.map(function (prefix) {
	      return value.replace(/filter\(/g, prefix + 'filter(');
	    });
	  }
	}
	module.exports = exports['default'];
	});

	var filter = unwrapExports(filter_1);

	var filter$1 = /*#__PURE__*/Object.freeze({
		default: filter,
		__moduleExports: filter_1
	});

	var flex_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = flex;
	var values = {
	  flex: ['-webkit-box', '-moz-box', '-ms-flexbox', '-webkit-flex', 'flex'],
	  'inline-flex': ['-webkit-inline-box', '-moz-inline-box', '-ms-inline-flexbox', '-webkit-inline-flex', 'inline-flex']
	};

	function flex(property, value) {
	  if (property === 'display' && values.hasOwnProperty(value)) {
	    return values[value];
	  }
	}
	module.exports = exports['default'];
	});

	var flex = unwrapExports(flex_1);

	var flex$1 = /*#__PURE__*/Object.freeze({
		default: flex,
		__moduleExports: flex_1
	});

	var flexboxIE_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = flexboxIE;
	var alternativeValues = {
	  'space-around': 'distribute',
	  'space-between': 'justify',
	  'flex-start': 'start',
	  'flex-end': 'end'
	};
	var alternativeProps = {
	  alignContent: 'msFlexLinePack',
	  alignSelf: 'msFlexItemAlign',
	  alignItems: 'msFlexAlign',
	  justifyContent: 'msFlexPack',
	  order: 'msFlexOrder',
	  flexGrow: 'msFlexPositive',
	  flexShrink: 'msFlexNegative',
	  flexBasis: 'msFlexPreferredSize'
	};

	function flexboxIE(property, value, style) {
	  if (alternativeProps.hasOwnProperty(property)) {
	    style[alternativeProps[property]] = alternativeValues[value] || value;
	  }
	}
	module.exports = exports['default'];
	});

	var flexboxIE = unwrapExports(flexboxIE_1);

	var flexboxIE$1 = /*#__PURE__*/Object.freeze({
		default: flexboxIE,
		__moduleExports: flexboxIE_1
	});

	var flexboxOld_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = flexboxOld;
	var alternativeValues = {
	  'space-around': 'justify',
	  'space-between': 'justify',
	  'flex-start': 'start',
	  'flex-end': 'end',
	  'wrap-reverse': 'multiple',
	  wrap: 'multiple'
	};

	var alternativeProps = {
	  alignItems: 'WebkitBoxAlign',
	  justifyContent: 'WebkitBoxPack',
	  flexWrap: 'WebkitBoxLines'
	};

	function flexboxOld(property, value, style) {
	  if (property === 'flexDirection' && typeof value === 'string') {
	    if (value.indexOf('column') > -1) {
	      style.WebkitBoxOrient = 'vertical';
	    } else {
	      style.WebkitBoxOrient = 'horizontal';
	    }
	    if (value.indexOf('reverse') > -1) {
	      style.WebkitBoxDirection = 'reverse';
	    } else {
	      style.WebkitBoxDirection = 'normal';
	    }
	  }
	  if (alternativeProps.hasOwnProperty(property)) {
	    style[alternativeProps[property]] = alternativeValues[value] || value;
	  }
	}
	module.exports = exports['default'];
	});

	var flexboxOld = unwrapExports(flexboxOld_1);

	var flexboxOld$1 = /*#__PURE__*/Object.freeze({
		default: flexboxOld,
		__moduleExports: flexboxOld_1
	});

	var gradient_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = gradient;



	var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var prefixes = ['-webkit-', '-moz-', ''];

	var values = /linear-gradient|radial-gradient|repeating-linear-gradient|repeating-radial-gradient/;

	function gradient(property, value) {
	  if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && values.test(value)) {
	    return prefixes.map(function (prefix) {
	      return prefix + value;
	    });
	  }
	}
	module.exports = exports['default'];
	});

	var gradient = unwrapExports(gradient_1);

	var gradient$1 = /*#__PURE__*/Object.freeze({
		default: gradient,
		__moduleExports: gradient_1
	});

	var imageSet_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = imageSet;



	var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// http://caniuse.com/#feat=css-image-set
	var prefixes = ['-webkit-', ''];
	function imageSet(property, value) {
	  if (typeof value === 'string' && !(0, _isPrefixedValue2.default)(value) && value.indexOf('image-set(') > -1) {
	    return prefixes.map(function (prefix) {
	      return value.replace(/image-set\(/g, prefix + 'image-set(');
	    });
	  }
	}
	module.exports = exports['default'];
	});

	var imageSet = unwrapExports(imageSet_1);

	var imageSet$1 = /*#__PURE__*/Object.freeze({
		default: imageSet,
		__moduleExports: imageSet_1
	});

	var position_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = position;
	function position(property, value) {
	  if (property === 'position' && value === 'sticky') {
	    return ['-webkit-sticky', 'sticky'];
	  }
	}
	module.exports = exports['default'];
	});

	var position = unwrapExports(position_1);

	var position$1 = /*#__PURE__*/Object.freeze({
		default: position,
		__moduleExports: position_1
	});

	var sizing_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = sizing;
	var prefixes = ['-webkit-', '-moz-', ''];

	var properties = {
	  maxHeight: true,
	  maxWidth: true,
	  width: true,
	  height: true,
	  columnWidth: true,
	  minWidth: true,
	  minHeight: true
	};
	var values = {
	  'min-content': true,
	  'max-content': true,
	  'fill-available': true,
	  'fit-content': true,
	  'contain-floats': true
	};

	function sizing(property, value) {
	  if (properties.hasOwnProperty(property) && values.hasOwnProperty(value)) {
	    return prefixes.map(function (prefix) {
	      return prefix + value;
	    });
	  }
	}
	module.exports = exports['default'];
	});

	var sizing = unwrapExports(sizing_1);

	var sizing$1 = /*#__PURE__*/Object.freeze({
		default: sizing,
		__moduleExports: sizing_1
	});

	var uppercasePattern = /[A-Z]/g;
	var msPattern = /^ms-/;
	var cache = {};

	function hyphenateStyleName(string) {
	    return string in cache
	    ? cache[string]
	    : cache[string] = string
	      .replace(uppercasePattern, '-$&')
	      .toLowerCase()
	      .replace(msPattern, '-ms-');
	}

	var hyphenateStyleName_1 = hyphenateStyleName;

	var hyphenateStyleName$1 = /*#__PURE__*/Object.freeze({
		default: hyphenateStyleName_1,
		__moduleExports: hyphenateStyleName_1
	});

	var _hyphenateStyleName = ( hyphenateStyleName$1 && hyphenateStyleName_1 ) || hyphenateStyleName$1;

	var hyphenateProperty_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = hyphenateProperty;



	var _hyphenateStyleName2 = _interopRequireDefault(_hyphenateStyleName);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function hyphenateProperty(property) {
	  return (0, _hyphenateStyleName2.default)(property);
	}
	module.exports = exports['default'];
	});

	var hyphenateProperty = unwrapExports(hyphenateProperty_1);

	var hyphenateProperty$1 = /*#__PURE__*/Object.freeze({
		default: hyphenateProperty,
		__moduleExports: hyphenateProperty_1
	});

	var _hyphenateProperty = ( hyphenateProperty$1 && hyphenateProperty ) || hyphenateProperty$1;

	var transition_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = transition;



	var _hyphenateProperty2 = _interopRequireDefault(_hyphenateProperty);



	var _isPrefixedValue2 = _interopRequireDefault(_isPrefixedValue);



	var _capitalizeString2 = _interopRequireDefault(_capitalizeString);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var properties = {
	  transition: true,
	  transitionProperty: true,
	  WebkitTransition: true,
	  WebkitTransitionProperty: true,
	  MozTransition: true,
	  MozTransitionProperty: true
	};


	var prefixMapping = {
	  Webkit: '-webkit-',
	  Moz: '-moz-',
	  ms: '-ms-'
	};

	function prefixValue(value, propertyPrefixMap) {
	  if ((0, _isPrefixedValue2.default)(value)) {
	    return value;
	  }

	  // only split multi values, not cubic beziers
	  var multipleValues = value.split(/,(?![^()]*(?:\([^()]*\))?\))/g);

	  for (var i = 0, len = multipleValues.length; i < len; ++i) {
	    var singleValue = multipleValues[i];
	    var values = [singleValue];
	    for (var property in propertyPrefixMap) {
	      var dashCaseProperty = (0, _hyphenateProperty2.default)(property);

	      if (singleValue.indexOf(dashCaseProperty) > -1 && dashCaseProperty !== 'order') {
	        var prefixes = propertyPrefixMap[property];
	        for (var j = 0, pLen = prefixes.length; j < pLen; ++j) {
	          // join all prefixes and create a new value
	          values.unshift(singleValue.replace(dashCaseProperty, prefixMapping[prefixes[j]] + dashCaseProperty));
	        }
	      }
	    }

	    multipleValues[i] = values.join(',');
	  }

	  return multipleValues.join(',');
	}

	function transition(property, value, style, propertyPrefixMap) {
	  // also check for already prefixed transitions
	  if (typeof value === 'string' && properties.hasOwnProperty(property)) {
	    var outputValue = prefixValue(value, propertyPrefixMap);
	    // if the property is already prefixed
	    var webkitOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
	      return !/-moz-|-ms-/.test(val);
	    }).join(',');

	    if (property.indexOf('Webkit') > -1) {
	      return webkitOutput;
	    }

	    var mozOutput = outputValue.split(/,(?![^()]*(?:\([^()]*\))?\))/g).filter(function (val) {
	      return !/-webkit-|-ms-/.test(val);
	    }).join(',');

	    if (property.indexOf('Moz') > -1) {
	      return mozOutput;
	    }

	    style['Webkit' + (0, _capitalizeString2.default)(property)] = webkitOutput;
	    style['Moz' + (0, _capitalizeString2.default)(property)] = mozOutput;
	    return outputValue;
	  }
	}
	module.exports = exports['default'];
	});

	var transition = unwrapExports(transition_1);

	var transition$1 = /*#__PURE__*/Object.freeze({
		default: transition,
		__moduleExports: transition_1
	});

	var calc$2 = ( calc$1 && calc ) || calc$1;

	var crossFade$2 = ( crossFade$1 && crossFade ) || crossFade$1;

	var cursor$2 = ( cursor$1 && cursor ) || cursor$1;

	var filter$2 = ( filter$1 && filter ) || filter$1;

	var flex$2 = ( flex$1 && flex ) || flex$1;

	var flexboxIE$2 = ( flexboxIE$1 && flexboxIE ) || flexboxIE$1;

	var flexboxOld$2 = ( flexboxOld$1 && flexboxOld ) || flexboxOld$1;

	var gradient$2 = ( gradient$1 && gradient ) || gradient$1;

	var imageSet$2 = ( imageSet$1 && imageSet ) || imageSet$1;

	var position$2 = ( position$1 && position ) || position$1;

	var sizing$2 = ( sizing$1 && sizing ) || sizing$1;

	var transition$2 = ( transition$1 && transition ) || transition$1;

	var staticPrefixData =  {
	  plugins: [calc$2,crossFade$2,cursor$2,filter$2,flex$2,flexboxIE$2,flexboxOld$2,gradient$2,imageSet$2,position$2,sizing$2,transition$2],
	  prefixMap: {"transform":["Webkit","ms"],"transformOrigin":["Webkit","ms"],"transformOriginX":["Webkit","ms"],"transformOriginY":["Webkit","ms"],"backfaceVisibility":["Webkit"],"perspective":["Webkit"],"perspectiveOrigin":["Webkit"],"transformStyle":["Webkit"],"transformOriginZ":["Webkit"],"animation":["Webkit"],"animationDelay":["Webkit"],"animationDirection":["Webkit"],"animationFillMode":["Webkit"],"animationDuration":["Webkit"],"animationIterationCount":["Webkit"],"animationName":["Webkit"],"animationPlayState":["Webkit"],"animationTimingFunction":["Webkit"],"appearance":["Webkit","Moz"],"userSelect":["Webkit","Moz","ms"],"fontKerning":["Webkit"],"textEmphasisPosition":["Webkit"],"textEmphasis":["Webkit"],"textEmphasisStyle":["Webkit"],"textEmphasisColor":["Webkit"],"boxDecorationBreak":["Webkit"],"clipPath":["Webkit"],"maskImage":["Webkit"],"maskMode":["Webkit"],"maskRepeat":["Webkit"],"maskPosition":["Webkit"],"maskClip":["Webkit"],"maskOrigin":["Webkit"],"maskSize":["Webkit"],"maskComposite":["Webkit"],"mask":["Webkit"],"maskBorderSource":["Webkit"],"maskBorderMode":["Webkit"],"maskBorderSlice":["Webkit"],"maskBorderWidth":["Webkit"],"maskBorderOutset":["Webkit"],"maskBorderRepeat":["Webkit"],"maskBorder":["Webkit"],"maskType":["Webkit"],"textDecorationStyle":["Webkit","Moz"],"textDecorationSkip":["Webkit","Moz"],"textDecorationLine":["Webkit","Moz"],"textDecorationColor":["Webkit","Moz"],"filter":["Webkit"],"fontFeatureSettings":["Webkit","Moz"],"breakAfter":["Webkit","Moz","ms"],"breakBefore":["Webkit","Moz","ms"],"breakInside":["Webkit","Moz","ms"],"columnCount":["Webkit","Moz"],"columnFill":["Webkit","Moz"],"columnGap":["Webkit","Moz"],"columnRule":["Webkit","Moz"],"columnRuleColor":["Webkit","Moz"],"columnRuleStyle":["Webkit","Moz"],"columnRuleWidth":["Webkit","Moz"],"columns":["Webkit","Moz"],"columnSpan":["Webkit","Moz"],"columnWidth":["Webkit","Moz"],"flex":["Webkit","ms"],"flexBasis":["Webkit"],"flexDirection":["Webkit","ms"],"flexGrow":["Webkit"],"flexFlow":["Webkit","ms"],"flexShrink":["Webkit"],"flexWrap":["Webkit","ms"],"alignContent":["Webkit"],"alignItems":["Webkit"],"alignSelf":["Webkit"],"justifyContent":["Webkit"],"order":["Webkit"],"transitionDelay":["Webkit"],"transitionDuration":["Webkit"],"transitionProperty":["Webkit"],"transitionTimingFunction":["Webkit"],"backdropFilter":["Webkit"],"scrollSnapType":["Webkit","ms"],"scrollSnapPointsX":["Webkit","ms"],"scrollSnapPointsY":["Webkit","ms"],"scrollSnapDestination":["Webkit","ms"],"scrollSnapCoordinate":["Webkit","ms"],"shapeImageThreshold":["Webkit"],"shapeImageMargin":["Webkit"],"shapeImageOutside":["Webkit"],"hyphens":["Webkit","Moz","ms"],"flowInto":["Webkit","ms"],"flowFrom":["Webkit","ms"],"regionFragment":["Webkit","ms"],"boxSizing":["Moz"],"textAlignLast":["Moz"],"tabSize":["Moz"],"wrapFlow":["ms"],"wrapThrough":["ms"],"wrapMargin":["ms"],"touchAction":["ms"],"gridTemplateColumns":["ms"],"gridTemplateRows":["ms"],"gridTemplateAreas":["ms"],"gridTemplate":["ms"],"gridAutoColumns":["ms"],"gridAutoRows":["ms"],"gridAutoFlow":["ms"],"grid":["ms"],"gridRowStart":["ms"],"gridColumnStart":["ms"],"gridRowEnd":["ms"],"gridRow":["ms"],"gridColumn":["ms"],"gridColumnEnd":["ms"],"gridColumnGap":["ms"],"gridRowGap":["ms"],"gridArea":["ms"],"gridGap":["ms"],"textSizeAdjust":["Webkit","ms"],"borderImage":["Webkit"],"borderImageOutset":["Webkit"],"borderImageRepeat":["Webkit"],"borderImageSlice":["Webkit"],"borderImageSource":["Webkit"],"borderImageWidth":["Webkit"]}
	};

	var staticPrefixData$1 = /*#__PURE__*/Object.freeze({
		default: staticPrefixData,
		__moduleExports: staticPrefixData
	});

	var orderedElements = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var MAP_EXISTS = typeof Map !== 'undefined';

	var OrderedElements = (function () {
	    /* ::
	    elements: {[string]: any};
	    keyOrder: string[];
	    */

	    function OrderedElements() {
	        _classCallCheck(this, OrderedElements);

	        this.elements = {};
	        this.keyOrder = [];
	    }

	    _createClass(OrderedElements, [{
	        key: 'forEach',
	        value: function forEach(callback /* : (string, any) => void */) {
	            for (var i = 0; i < this.keyOrder.length; i++) {
	                // (value, key) to match Map's API
	                callback(this.elements[this.keyOrder[i]], this.keyOrder[i]);
	            }
	        }
	    }, {
	        key: 'set',
	        value: function set(key, /* : string */value, /* : any */shouldReorder /* : ?boolean */) {
	            var _this = this;

	            if (!this.elements.hasOwnProperty(key)) {
	                this.keyOrder.push(key);
	            } else if (shouldReorder) {
	                var index = this.keyOrder.indexOf(key);
	                this.keyOrder.splice(index, 1);
	                this.keyOrder.push(key);
	            }

	            if (value == null) {
	                this.elements[key] = value;
	                return;
	            }

	            if (MAP_EXISTS && value instanceof Map || value instanceof OrderedElements) {
	                var _ret = (function () {
	                    // We have found a nested Map, so we need to recurse so that all
	                    // of the nested objects and Maps are merged properly.
	                    var nested = _this.elements.hasOwnProperty(key) ? _this.elements[key] : new OrderedElements();
	                    value.forEach(function (value, key) {
	                        nested.set(key, value, shouldReorder);
	                    });
	                    _this.elements[key] = nested;
	                    return {
	                        v: undefined
	                    };
	                })();

	                if (typeof _ret === 'object') return _ret.v;
	            }

	            if (!Array.isArray(value) && typeof value === 'object') {
	                // We have found a nested object, so we need to recurse so that all
	                // of the nested objects and Maps are merged properly.
	                var nested = this.elements.hasOwnProperty(key) ? this.elements[key] : new OrderedElements();
	                var keys = Object.keys(value);
	                for (var i = 0; i < keys.length; i += 1) {
	                    nested.set(keys[i], value[keys[i]], shouldReorder);
	                }
	                this.elements[key] = nested;
	                return;
	            }

	            this.elements[key] = value;
	        }
	    }, {
	        key: 'get',
	        value: function get(key /* : string */) /* : any */{
	            return this.elements[key];
	        }
	    }, {
	        key: 'has',
	        value: function has(key /* : string */) /* : boolean */{
	            return this.elements.hasOwnProperty(key);
	        }
	    }, {
	        key: 'addStyleType',
	        value: function addStyleType(styleType /* : any */) /* : void */{
	            var _this2 = this;

	            if (MAP_EXISTS && styleType instanceof Map || styleType instanceof OrderedElements) {
	                styleType.forEach(function (value, key) {
	                    _this2.set(key, value, true);
	                });
	            } else {
	                var keys = Object.keys(styleType);
	                for (var i = 0; i < keys.length; i++) {
	                    this.set(keys[i], styleType[keys[i]], true);
	                }
	            }
	        }
	    }]);

	    return OrderedElements;
	})();

	exports['default'] = OrderedElements;
	module.exports = exports['default'];
	});

	var orderedElements$1 = unwrapExports(orderedElements);

	var orderedElements$2 = /*#__PURE__*/Object.freeze({
		default: orderedElements$1,
		__moduleExports: orderedElements
	});

	function hash(str) {
	  var hash = 5381,
	      i    = str.length;

	  while(i) {
	    hash = (hash * 33) ^ str.charCodeAt(--i);
	  }

	  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
	   * integers. Since we want the results to be always positive, convert the
	   * signed int to an unsigned by doing an unsigned bitshift. */
	  return hash >>> 0;
	}

	var stringHash = hash;

	var stringHash$1 = /*#__PURE__*/Object.freeze({
		default: stringHash,
		__moduleExports: stringHash
	});

	var _stringHash = ( stringHash$1 && stringHash ) || stringHash$1;

	var util = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _stringHash2 = _interopRequireDefault(_stringHash);

	/* ::
	type Pair = [ string, any ];
	type Pairs = Pair[];
	type PairsMapper = (pair: Pair) => Pair;
	type ObjectMap = { [id:string]: any };
	*/

	var mapObj = function mapObj(obj, /* : ObjectMap */
	fn /* : PairsMapper */
	) /* : ObjectMap */{
	    var keys = Object.keys(obj);
	    var mappedObj = {};
	    for (var i = 0; i < keys.length; i += 1) {
	        var _fn = fn([keys[i], obj[keys[i]]]);

	        var _fn2 = _slicedToArray(_fn, 2);

	        var newKey = _fn2[0];
	        var newValue = _fn2[1];

	        mappedObj[newKey] = newValue;
	    }
	    return mappedObj;
	};

	exports.mapObj = mapObj;
	var UPPERCASE_RE = /([A-Z])/g;
	var UPPERCASE_RE_TO_KEBAB = function UPPERCASE_RE_TO_KEBAB(match /* : string */) {
	    return (/* : string */'-' + match.toLowerCase()
	    );
	};

	var kebabifyStyleName = function kebabifyStyleName(string /* : string */) /* : string */{
	    var result = string.replace(UPPERCASE_RE, UPPERCASE_RE_TO_KEBAB);
	    if (result[0] === 'm' && result[1] === 's' && result[2] === '-') {
	        return '-' + result;
	    }
	    return result;
	};

	exports.kebabifyStyleName = kebabifyStyleName;
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 * Taken from React's CSSProperty.js
	 */
	var isUnitlessNumber = {
	    animationIterationCount: true,
	    borderImageOutset: true,
	    borderImageSlice: true,
	    borderImageWidth: true,
	    boxFlex: true,
	    boxFlexGroup: true,
	    boxOrdinalGroup: true,
	    columnCount: true,
	    flex: true,
	    flexGrow: true,
	    flexPositive: true,
	    flexShrink: true,
	    flexNegative: true,
	    flexOrder: true,
	    gridRow: true,
	    gridColumn: true,
	    fontWeight: true,
	    lineClamp: true,
	    lineHeight: true,
	    opacity: true,
	    order: true,
	    orphans: true,
	    tabSize: true,
	    widows: true,
	    zIndex: true,
	    zoom: true,

	    // SVG-related properties
	    fillOpacity: true,
	    floodOpacity: true,
	    stopOpacity: true,
	    strokeDasharray: true,
	    strokeDashoffset: true,
	    strokeMiterlimit: true,
	    strokeOpacity: true,
	    strokeWidth: true
	};

	/**
	 * Taken from React's CSSProperty.js
	 *
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	    return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}

	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 * Taken from React's CSSProperty.js
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	// Taken from React's CSSProperty.js
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	    prefixes.forEach(function (prefix) {
	        isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	    });
	});

	var stringifyValue = function stringifyValue(key, /* : string */
	prop /* : any */
	) /* : string */{
	    if (typeof prop === "number") {
	        if (isUnitlessNumber[key]) {
	            return "" + prop;
	        } else {
	            return prop + "px";
	        }
	    } else {
	        return '' + prop;
	    }
	};

	exports.stringifyValue = stringifyValue;
	var stringifyAndImportantifyValue = function stringifyAndImportantifyValue(key, /* : string */
	prop /* : any */
	) {
	    return (/* : string */importantify(stringifyValue(key, prop))
	    );
	};

	exports.stringifyAndImportantifyValue = stringifyAndImportantifyValue;
	// Turn a string into a hash string of base-36 values (using letters and numbers)
	var hashString = function hashString(string /* : string */) {
	    return (/* string */(0, _stringHash2['default'])(string).toString(36)
	    );
	};

	exports.hashString = hashString;
	// Hash a javascript object using JSON.stringify. This is very fast, about 3
	// microseconds on my computer for a sample object:
	// http://jsperf.com/test-hashfnv32a-hash/5
	//
	// Note that this uses JSON.stringify to stringify the objects so in order for
	// this to produce consistent hashes browsers need to have a consistent
	// ordering of objects. Ben Alpert says that Facebook depends on this, so we
	// can probably depend on this too.
	var hashObject = function hashObject(object /* : ObjectMap */) {
	    return (/* : string */hashString(JSON.stringify(object))
	    );
	};

	exports.hashObject = hashObject;
	// Given a single style value string like the "b" from "a: b;", adds !important
	// to generate "b !important".
	var importantify = function importantify(string /* : string */) {
	    return (/* : string */
	        // Bracket string character access is very fast, and in the default case we
	        // normally don't expect there to be "!important" at the end of the string
	        // so we can use this simple check to take an optimized path. If there
	        // happens to be a "!" in this position, we follow up with a more thorough
	        // check.
	        string[string.length - 10] === '!' && string.slice(-11) === ' !important' ? string : string + ' !important'
	    );
	};
	});

	var util$1 = unwrapExports(util);
	var util_1 = util.mapObj;
	var util_2 = util.kebabifyStyleName;
	var util_3 = util.stringifyValue;
	var util_4 = util.stringifyAndImportantifyValue;
	var util_5 = util.hashString;
	var util_6 = util.hashObject;

	var util$2 = /*#__PURE__*/Object.freeze({
		default: util$1,
		__moduleExports: util,
		mapObj: util_1,
		kebabifyStyleName: util_2,
		stringifyValue: util_3,
		stringifyAndImportantifyValue: util_4,
		hashString: util_5,
		hashObject: util_6
	});

	var _inlineStylePrefixerStaticCreatePrefixer = ( createPrefixer$1 && createPrefixer ) || createPrefixer$1;

	var _libStaticPrefixData = ( staticPrefixData$1 && staticPrefixData ) || staticPrefixData$1;

	var _orderedElements = ( orderedElements$2 && orderedElements$1 ) || orderedElements$2;

	var _util = ( util$2 && util$1 ) || util$2;

	var generate = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _inlineStylePrefixerStaticCreatePrefixer2 = _interopRequireDefault(_inlineStylePrefixerStaticCreatePrefixer);



	var _libStaticPrefixData2 = _interopRequireDefault(_libStaticPrefixData);



	var _orderedElements2 = _interopRequireDefault(_orderedElements);



	var prefixAll = (0, _inlineStylePrefixerStaticCreatePrefixer2['default'])(_libStaticPrefixData2['default']);

	/* ::
	import type { SheetDefinition } from './index.js';
	type StringHandlers = { [id:string]: Function };
	type SelectorCallback = (selector: string) => any;
	export type SelectorHandler = (
	    selector: string,
	    baseSelector: string,
	    callback: SelectorCallback
	) => string | null;
	*/

	/**
	 * `selectorHandlers` are functions which handle special selectors which act
	 * differently than normal style definitions. These functions look at the
	 * current selector and can generate CSS for the styles in their subtree by
	 * calling the callback with a new selector.
	 *
	 * For example, when generating styles with a base selector of '.foo' and the
	 * following styles object:
	 *
	 *   {
	 *     ':nth-child(2n)': {
	 *       ':hover': {
	 *         color: 'red'
	 *       }
	 *     }
	 *   }
	 *
	 * when we reach the ':hover' style, we would call our selector handlers like
	 *
	 *   handler(':hover', '.foo:nth-child(2n)', callback)
	 *
	 * Since our `pseudoSelectors` handles ':hover' styles, that handler would call
	 * the callback like
	 *
	 *   callback('.foo:nth-child(2n):hover')
	 *
	 * to generate its subtree `{ color: 'red' }` styles with a
	 * '.foo:nth-child(2n):hover' selector. The callback would return CSS like
	 *
	 *   '.foo:nth-child(2n):hover{color:red !important;}'
	 *
	 * and the handler would then return that resulting CSS.
	 *
	 * `defaultSelectorHandlers` is the list of default handlers used in a call to
	 * `generateCSS`.
	 *
	 * @name SelectorHandler
	 * @function
	 * @param {string} selector: The currently inspected selector. ':hover' in the
	 *     example above.
	 * @param {string} baseSelector: The selector of the parent styles.
	 *     '.foo:nth-child(2n)' in the example above.
	 * @param {function} generateSubtreeStyles: A function which can be called to
	 *     generate CSS for the subtree of styles corresponding to the selector.
	 *     Accepts a new baseSelector to use for generating those styles.
	 * @returns {?string} The generated CSS for this selector, or null if we don't
	 *     handle this selector.
	 */
	var defaultSelectorHandlers = [
	// Handle pseudo-selectors, like :hover and :nth-child(3n)
	function pseudoSelectors(selector, /* : string */
	baseSelector, /* : string */
	generateSubtreeStyles /* : Function */
	) /* */{
	    if (selector[0] !== ":") {
	        return null;
	    }
	    return generateSubtreeStyles(baseSelector + selector);
	},

	// Handle media queries (or font-faces)
	function mediaQueries(selector, /* : string */
	baseSelector, /* : string */
	generateSubtreeStyles /* : Function */
	) /* */{
	    if (selector[0] !== "@") {
	        return null;
	    }
	    // Generate the styles normally, and then wrap them in the media query.
	    var generated = generateSubtreeStyles(baseSelector);
	    return selector + '{' + generated + '}';
	}];

	exports.defaultSelectorHandlers = defaultSelectorHandlers;
	/**
	 * Generate CSS for a selector and some styles.
	 *
	 * This function handles the media queries and pseudo selectors that can be used
	 * in aphrodite styles.
	 *
	 * @param {string} selector: A base CSS selector for the styles to be generated
	 *     with.
	 * @param {Object} styleTypes: A list of properties of the return type of
	 *     StyleSheet.create, e.g. [styles.red, styles.blue].
	 * @param {Array.<SelectorHandler>} selectorHandlers: A list of selector
	 *     handlers to use for handling special selectors. See
	 *     `defaultSelectorHandlers`.
	 * @param stringHandlers: See `generateCSSRuleset`
	 * @param useImportant: See `generateCSSRuleset`
	 *
	 * To actually generate the CSS special-construct-less styles are passed to
	 * `generateCSSRuleset`.
	 *
	 * For instance, a call to
	 *
	 *     generateCSS(".foo", [{
	 *       color: "red",
	 *       "@media screen": {
	 *         height: 20,
	 *         ":hover": {
	 *           backgroundColor: "black"
	 *         }
	 *       },
	 *       ":active": {
	 *         fontWeight: "bold"
	 *       }
	 *     }], defaultSelectorHandlers);
	 *
	 * with the default `selectorHandlers` will make 5 calls to
	 * `generateCSSRuleset`:
	 *
	 *     generateCSSRuleset(".foo", { color: "red" }, ...)
	 *     generateCSSRuleset(".foo:active", { fontWeight: "bold" }, ...)
	 *     // These 2 will be wrapped in @media screen {}
	 *     generateCSSRuleset(".foo", { height: 20 }, ...)
	 *     generateCSSRuleset(".foo:hover", { backgroundColor: "black" }, ...)
	 */
	var generateCSS = function generateCSS(selector, /* : string */
	styleTypes, /* : SheetDefinition[] */
	selectorHandlers, /* : SelectorHandler[] */
	stringHandlers, /* : StringHandlers */
	useImportant /* : boolean */
	) /* : string */{
	    var merged = new _orderedElements2['default']();

	    for (var i = 0; i < styleTypes.length; i++) {
	        merged.addStyleType(styleTypes[i]);
	    }

	    var plainDeclarations = new _orderedElements2['default']();
	    var generatedStyles = "";

	    // TODO(emily): benchmark this to see if a plain for loop would be faster.
	    merged.forEach(function (val, key) {
	        // For each key, see if one of the selector handlers will handle these
	        // styles.
	        var foundHandler = selectorHandlers.some(function (handler) {
	            var result = handler(key, selector, function (newSelector) {
	                return generateCSS(newSelector, [val], selectorHandlers, stringHandlers, useImportant);
	            });
	            if (result != null) {
	                // If the handler returned something, add it to the generated
	                // CSS and stop looking for another handler.
	                generatedStyles += result;
	                return true;
	            }
	        });
	        // If none of the handlers handled it, add it to the list of plain
	        // style declarations.
	        if (!foundHandler) {
	            plainDeclarations.set(key, val, true);
	        }
	    });

	    return generateCSSRuleset(selector, plainDeclarations, stringHandlers, useImportant, selectorHandlers) + generatedStyles;
	};

	exports.generateCSS = generateCSS;
	/**
	 * Helper method of generateCSSRuleset to facilitate custom handling of certain
	 * CSS properties. Used for e.g. font families.
	 *
	 * See generateCSSRuleset for usage and documentation of paramater types.
	 */
	var runStringHandlers = function runStringHandlers(declarations, /* : OrderedElements */
	stringHandlers, /* : StringHandlers */
	selectorHandlers /* : SelectorHandler[] */
	) /* : void */{
	    if (!stringHandlers) {
	        return;
	    }

	    var stringHandlerKeys = Object.keys(stringHandlers);
	    for (var i = 0; i < stringHandlerKeys.length; i++) {
	        var key = stringHandlerKeys[i];
	        if (declarations.has(key)) {
	            // A declaration exists for this particular string handler, so we
	            // need to let the string handler interpret the declaration first
	            // before proceeding.
	            //
	            // TODO(emily): Pass in a callback which generates CSS, similar to
	            // how our selector handlers work, instead of passing in
	            // `selectorHandlers` and have them make calls to `generateCSS`
	            // themselves. Right now, this is impractical because our string
	            // handlers are very specialized and do complex things.
	            declarations.set(key, stringHandlers[key](declarations.get(key), selectorHandlers),

	            // Preserve order here, since we are really replacing an
	            // unprocessed style with a processed style, not overriding an
	            // earlier style
	            false);
	        }
	    }
	};

	var transformRule = function transformRule(key, /* : string */
	value, /* : string */
	transformValue /* : function */
	) {
	    return (/* : string */(0, _util.kebabifyStyleName)(key) + ':' + transformValue(key, value) + ';'
	    );
	};

	/**
	 * Generate a CSS ruleset with the selector and containing the declarations.
	 *
	 * This function assumes that the given declarations don't contain any special
	 * children (such as media queries, pseudo-selectors, or descendant styles).
	 *
	 * Note that this method does not deal with nesting used for e.g.
	 * psuedo-selectors or media queries. That responsibility is left to  the
	 * `generateCSS` function.
	 *
	 * @param {string} selector: the selector associated with the ruleset
	 * @param {Object} declarations: a map from camelCased CSS property name to CSS
	 *     property value.
	 * @param {Object.<string, function>} stringHandlers: a map from camelCased CSS
	 *     property name to a function which will map the given value to the value
	 *     that is output.
	 * @param {bool} useImportant: A boolean saying whether to append "!important"
	 *     to each of the CSS declarations.
	 * @returns {string} A string of raw CSS.
	 *
	 * Examples:
	 *
	 *    generateCSSRuleset(".blah", { color: "red" })
	 *    -> ".blah{color: red !important;}"
	 *    generateCSSRuleset(".blah", { color: "red" }, {}, false)
	 *    -> ".blah{color: red}"
	 *    generateCSSRuleset(".blah", { color: "red" }, {color: c => c.toUpperCase})
	 *    -> ".blah{color: RED}"
	 *    generateCSSRuleset(".blah:hover", { color: "red" })
	 *    -> ".blah:hover{color: red}"
	 */
	var generateCSSRuleset = function generateCSSRuleset(selector, /* : string */
	declarations, /* : OrderedElements */
	stringHandlers, /* : StringHandlers */
	useImportant, /* : boolean */
	selectorHandlers /* : SelectorHandler[] */
	) /* : string */{
	    // Mutates declarations
	    runStringHandlers(declarations, stringHandlers, selectorHandlers);

	    var originalElements = _extends({}, declarations.elements);

	    // NOTE(emily): This mutates handledDeclarations.elements.
	    var prefixedElements = prefixAll(declarations.elements);

	    var elementNames = Object.keys(prefixedElements);
	    if (elementNames.length !== declarations.keyOrder.length) {
	        // There are some prefixed values, so we need to figure out how to sort
	        // them.
	        //
	        // Loop through prefixedElements, looking for anything that is not in
	        // sortOrder, which means it was added by prefixAll. This means that we
	        // need to figure out where it should appear in the sortOrder.
	        for (var i = 0; i < elementNames.length; i++) {
	            if (!originalElements.hasOwnProperty(elementNames[i])) {
	                // This element is not in the sortOrder, which means it is a prefixed
	                // value that was added by prefixAll. Let's try to figure out where it
	                // goes.
	                var originalStyle = undefined;
	                if (elementNames[i][0] === 'W') {
	                    // This is a Webkit-prefixed style, like "WebkitTransition". Let's
	                    // find its original style's sort order.
	                    originalStyle = elementNames[i][6].toLowerCase() + elementNames[i].slice(7);
	                } else if (elementNames[i][1] === 'o') {
	                    // This is a Moz-prefixed style, like "MozTransition". We check
	                    // the second character to avoid colliding with Ms-prefixed
	                    // styles. Let's find its original style's sort order.
	                    originalStyle = elementNames[i][3].toLowerCase() + elementNames[i].slice(4);
	                } else {
	                    // if (elementNames[i][1] === 's') {
	                    // This is a Ms-prefixed style, like "MsTransition".
	                    originalStyle = elementNames[i][2].toLowerCase() + elementNames[i].slice(3);
	                }

	                if (originalStyle && originalElements.hasOwnProperty(originalStyle)) {
	                    var originalIndex = declarations.keyOrder.indexOf(originalStyle);
	                    declarations.keyOrder.splice(originalIndex, 0, elementNames[i]);
	                } else {
	                    // We don't know what the original style was, so sort it to
	                    // top. This can happen for styles that are added that don't
	                    // have the same base name as the original style.
	                    declarations.keyOrder.unshift(elementNames[i]);
	                }
	            }
	        }
	    }

	    var transformValue = useImportant === false ? _util.stringifyValue : _util.stringifyAndImportantifyValue;

	    var rules = [];
	    for (var i = 0; i < declarations.keyOrder.length; i++) {
	        var key = declarations.keyOrder[i];
	        var value = prefixedElements[key];
	        if (Array.isArray(value)) {
	            // inline-style-prefixer returns an array when there should be
	            // multiple rules for the same key. Here we flatten to multiple
	            // pairs with the same key.
	            for (var j = 0; j < value.length; j++) {
	                rules.push(transformRule(key, value[j], transformValue));
	            }
	        } else {
	            rules.push(transformRule(key, value, transformValue));
	        }
	    }

	    if (rules.length) {
	        return selector + '{' + rules.join("") + '}';
	    } else {
	        return "";
	    }
	};
	exports.generateCSSRuleset = generateCSSRuleset;
	});

	var generate$1 = unwrapExports(generate);
	var generate_1 = generate.defaultSelectorHandlers;
	var generate_2 = generate.generateCSS;
	var generate_3 = generate.generateCSSRuleset;

	var generate$2 = /*#__PURE__*/Object.freeze({
		default: generate$1,
		__moduleExports: generate,
		defaultSelectorHandlers: generate_1,
		generateCSS: generate_2,
		generateCSSRuleset: generate_3
	});

	var global$1 = typeof global !== "undefined" ? global :
	            typeof self !== "undefined" ? self :
	            typeof window !== "undefined" ? window : {};

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$1.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$1.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}

	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config = {};

	function noop() {}

	var on = noop;
	var addListener = noop;
	var once = noop;
	var off = noop;
	var removeListener = noop;
	var removeAllListeners = noop;
	var emit = noop;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
	function chdir (dir) {
	    throw new Error('process.chdir is not supported');
	}function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$1.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var process = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform,
	  release: release,
	  config: config,
	  uptime: uptime
	};

	var domain; // The domain module is executed on demand
	var hasSetImmediate = typeof setImmediate === "function";

	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including network IO events in Node.js.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	var raw = rawAsap;
	function rawAsap(task) {
	    if (!queue$1.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Avoids a function call
	    queue$1[queue$1.length] = task;
	}

	var queue$1 = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory excaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;

	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue$1.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue$1[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue$1.length - index; scan < newLength; scan++) {
	                queue$1[scan] = queue$1[scan + index];
	            }
	            queue$1.length -= index;
	            index = 0;
	        }
	    }
	    queue$1.length = 0;
	    index = 0;
	    flushing = false;
	}

	rawAsap.requestFlush = requestFlush;
	function requestFlush() {
	    // Ensure flushing is not bound to any domain.
	    // It is not sufficient to exit the domain, because domains exist on a stack.
	    // To execute code outside of any domain, the following dance is necessary.
	    var parentDomain = process.domain;
	    if (parentDomain) {
	        if (!domain) {
	            // Lazy execute the domain module.
	            // Only employed if the user elects to use domains.
	            domain = require("domain");
	        }
	        domain.active = process.domain = null;
	    }

	    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
	    // cannot handle recursion.
	    // `requestFlush` will only be called recursively from `asap.js`, to resume
	    // flushing after an error is thrown into a domain.
	    // Conveniently, `setImmediate` was introduced in the same version
	    // `process.nextTick` started throwing recursion errors.
	    if (flushing && hasSetImmediate) {
	        setImmediate(flush);
	    } else {
	        nextTick(flush);
	    }

	    if (parentDomain) {
	        domain.active = process.domain = parentDomain;
	    }
	}

	var raw$1 = /*#__PURE__*/Object.freeze({
		default: raw,
		__moduleExports: raw
	});

	var rawAsap$1 = ( raw$1 && raw ) || raw$1;

	var freeTasks = [];

	/**
	 * Calls a task as soon as possible after returning, in its own event, with
	 * priority over IO events. An exception thrown in a task can be handled by
	 * `process.on("uncaughtException") or `domain.on("error")`, but will otherwise
	 * crash the process. If the error is handled, all subsequent tasks will
	 * resume.
	 *
	 * @param {{call}} task A callable object, typically a function that takes no
	 * arguments.
	 */
	var asap_1 = asap;
	function asap(task) {
	    var rawTask;
	    if (freeTasks.length) {
	        rawTask = freeTasks.pop();
	    } else {
	        rawTask = new RawTask();
	    }
	    rawTask.task = task;
	    rawTask.domain = process.domain;
	    rawAsap$1(rawTask);
	}

	function RawTask() {
	    this.task = null;
	    this.domain = null;
	}

	RawTask.prototype.call = function () {
	    if (this.domain) {
	        this.domain.enter();
	    }
	    var threw = true;
	    try {
	        this.task.call();
	        threw = false;
	        // If the task throws an exception (presumably) Node.js restores the
	        // domain stack for the next event.
	        if (this.domain) {
	            this.domain.exit();
	        }
	    } finally {
	        // We use try/finally and a threw flag to avoid messing up stack traces
	        // when we catch and release errors.
	        if (threw) {
	            // In Node.js, uncaught exceptions are considered fatal errors.
	            // Re-throw them to interrupt flushing!
	            // Ensure that flushing continues if an uncaught exception is
	            // suppressed listening process.on("uncaughtException") or
	            // domain.on("error").
	            rawAsap$1.requestFlush();
	        }
	        // If the task threw an error, we do not want to exit the domain here.
	        // Exiting the domain would prevent the domain from catching the error.
	        this.task = null;
	        this.domain = null;
	        freeTasks.push(this);
	    }
	};

	var _generate = ( generate$2 && generate$1 ) || generate$2;

	var inject = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



	var _asap2 = _interopRequireDefault(asap_1);



	var _orderedElements2 = _interopRequireDefault(_orderedElements);





	/* ::
	import type { SheetDefinition, SheetDefinitions } from './index.js';
	import type { MaybeSheetDefinition } from './exports.js';
	import type { SelectorHandler } from './generate.js';
	type ProcessedStyleDefinitions = {
	  classNameBits: Array<string>,
	  definitionBits: Array<Object>,
	};
	*/

	// The current <style> tag we are inserting into, or null if we haven't
	// inserted anything yet. We could find this each time using
	// `document.querySelector("style[data-aphrodite"])`, but holding onto it is
	// faster.
	var styleTag = null;

	// Inject a string of styles into a <style> tag in the head of the document. This
	// will automatically create a style tag and then continue to use it for
	// multiple injections. It will also use a style tag with the `data-aphrodite`
	// tag on it if that exists in the DOM. This could be used for e.g. reusing the
	// same style tag that server-side rendering inserts.
	var injectStyleTag = function injectStyleTag(cssContents /* : string */) {
	    if (styleTag == null) {
	        // Try to find a style tag with the `data-aphrodite` attribute first.
	        styleTag = document.querySelector("style[data-aphrodite]");

	        // If that doesn't work, generate a new style tag.
	        if (styleTag == null) {
	            // Taken from
	            // http://stackoverflow.com/questions/524696/how-to-create-a-style-tag-with-javascript
	            var head = document.head || document.getElementsByTagName('head')[0];
	            styleTag = document.createElement('style');

	            styleTag.type = 'text/css';
	            styleTag.setAttribute("data-aphrodite", "");
	            head.appendChild(styleTag);
	        }
	    }

	    if (styleTag.styleSheet) {
	        // $FlowFixMe: legacy Internet Explorer compatibility
	        styleTag.styleSheet.cssText += cssContents;
	    } else {
	        styleTag.appendChild(document.createTextNode(cssContents));
	    }
	};

	// Custom handlers for stringifying CSS values that have side effects
	// (such as fontFamily, which can cause @font-face rules to be injected)
	var stringHandlers = {
	    // With fontFamily we look for objects that are passed in and interpret
	    // them as @font-face rules that we need to inject. The value of fontFamily
	    // can either be a string (as normal), an object (a single font face), or
	    // an array of objects and strings.
	    fontFamily: function fontFamily(val) {
	        if (Array.isArray(val)) {
	            return val.map(fontFamily).join(",");
	        } else if (typeof val === "object") {
	            injectStyleOnce(val.src, "@font-face", [val], false);
	            return '"' + val.fontFamily + '"';
	        } else {
	            return val;
	        }
	    },

	    // With animationName we look for an object that contains keyframes and
	    // inject them as an `@keyframes` block, returning a uniquely generated
	    // name. The keyframes object should look like
	    //  animationName: {
	    //    from: {
	    //      left: 0,
	    //      top: 0,
	    //    },
	    //    '50%': {
	    //      left: 15,
	    //      top: 5,
	    //    },
	    //    to: {
	    //      left: 20,
	    //      top: 20,
	    //    }
	    //  }
	    // TODO(emily): `stringHandlers` doesn't let us rename the key, so I have
	    // to use `animationName` here. Improve that so we can call this
	    // `animation` instead of `animationName`.
	    animationName: function animationName(val, selectorHandlers) {
	        if (Array.isArray(val)) {
	            return val.map(function (v) {
	                return animationName(v, selectorHandlers);
	            }).join(",");
	        } else if (typeof val === "object") {
	            // Generate a unique name based on the hash of the object. We can't
	            // just use the hash because the name can't start with a number.
	            // TODO(emily): this probably makes debugging hard, allow a custom
	            // name?
	            var _name = 'keyframe_' + (0, _util.hashObject)(val);

	            // Since keyframes need 3 layers of nesting, we use `generateCSS` to
	            // build the inner layers and wrap it in `@keyframes` ourselves.
	            var finalVal = '@keyframes ' + _name + '{';

	            // TODO see if we can find a way where checking for OrderedElements
	            // here is not necessary. Alternatively, perhaps we should have a
	            // utility method that can iterate over either a plain object, an
	            // instance of OrderedElements, or a Map, and then use that here and
	            // elsewhere.
	            if (val instanceof _orderedElements2['default']) {
	                val.forEach(function (valVal, valKey) {
	                    finalVal += (0, _generate.generateCSS)(valKey, [valVal], selectorHandlers, stringHandlers, false);
	                });
	            } else {
	                Object.keys(val).forEach(function (key) {
	                    finalVal += (0, _generate.generateCSS)(key, [val[key]], selectorHandlers, stringHandlers, false);
	                });
	            }
	            finalVal += '}';

	            injectGeneratedCSSOnce(_name, finalVal);

	            return _name;
	        } else {
	            return val;
	        }
	    }
	};

	// This is a map from Aphrodite's generated class names to `true` (acting as a
	// set of class names)
	var alreadyInjected = {};

	// This is the buffer of styles which have not yet been flushed.
	var injectionBuffer = "";

	// A flag to tell if we are already buffering styles. This could happen either
	// because we scheduled a flush call already, so newly added styles will
	// already be flushed, or because we are statically buffering on the server.
	var isBuffering = false;

	var injectGeneratedCSSOnce = function injectGeneratedCSSOnce(key, generatedCSS) {
	    if (alreadyInjected[key]) {
	        return;
	    }

	    if (!isBuffering) {
	        // We should never be automatically buffering on the server (or any
	        // place without a document), so guard against that.
	        if (typeof document === "undefined") {
	            throw new Error("Cannot automatically buffer without a document");
	        }

	        // If we're not already buffering, schedule a call to flush the
	        // current styles.
	        isBuffering = true;
	        (0, _asap2['default'])(flushToStyleTag);
	    }

	    injectionBuffer += generatedCSS;
	    alreadyInjected[key] = true;
	};

	var injectStyleOnce = function injectStyleOnce(key, /* : string */
	selector, /* : string */
	definitions, /* : SheetDefinition[] */
	useImportant /* : boolean */
	) {
	    var selectorHandlers /* : SelectorHandler[] */ = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];

	    if (alreadyInjected[key]) {
	        return;
	    }

	    var generated = (0, _generate.generateCSS)(selector, definitions, selectorHandlers, stringHandlers, useImportant);

	    injectGeneratedCSSOnce(key, generated);
	};

	exports.injectStyleOnce = injectStyleOnce;
	var reset = function reset() {
	    injectionBuffer = "";
	    alreadyInjected = {};
	    isBuffering = false;
	    styleTag = null;
	};

	exports.reset = reset;
	var startBuffering = function startBuffering() {
	    if (isBuffering) {
	        throw new Error("Cannot buffer while already buffering");
	    }
	    isBuffering = true;
	};

	exports.startBuffering = startBuffering;
	var flushToString = function flushToString() {
	    isBuffering = false;
	    var ret = injectionBuffer;
	    injectionBuffer = "";
	    return ret;
	};

	exports.flushToString = flushToString;
	var flushToStyleTag = function flushToStyleTag() {
	    var cssContent = flushToString();
	    if (cssContent.length > 0) {
	        injectStyleTag(cssContent);
	    }
	};

	exports.flushToStyleTag = flushToStyleTag;
	var getRenderedClassNames = function getRenderedClassNames() {
	    return Object.keys(alreadyInjected);
	};

	exports.getRenderedClassNames = getRenderedClassNames;
	var addRenderedClassNames = function addRenderedClassNames(classNames /* : string[] */) {
	    classNames.forEach(function (className) {
	        alreadyInjected[className] = true;
	    });
	};

	exports.addRenderedClassNames = addRenderedClassNames;
	var processStyleDefinitions = function processStyleDefinitions(styleDefinitions, /* : any[] */
	result /* : ProcessedStyleDefinitions */
	) /* : void */{
	    for (var i = 0; i < styleDefinitions.length; i += 1) {
	        // Filter out falsy values from the input, to allow for
	        // `css(a, test && c)`
	        if (styleDefinitions[i]) {
	            if (Array.isArray(styleDefinitions[i])) {
	                // We've encountered an array, so let's recurse
	                processStyleDefinitions(styleDefinitions[i], result);
	            } else {
	                result.classNameBits.push(styleDefinitions[i]._name);
	                result.definitionBits.push(styleDefinitions[i]._definition);
	            }
	        }
	    }
	};

	/**
	 * Inject styles associated with the passed style definition objects, and return
	 * an associated CSS class name.
	 *
	 * @param {boolean} useImportant If true, will append !important to generated
	 *     CSS output. e.g. {color: red} -> "color: red !important".
	 * @param {(Object|Object[])[]} styleDefinitions style definition objects, or
	 *     arbitrarily nested arrays of them, as returned as properties of the
	 *     return value of StyleSheet.create().
	 */
	var injectAndGetClassName = function injectAndGetClassName(useImportant, /* : boolean */
	styleDefinitions, /* : MaybeSheetDefinition[] */
	selectorHandlers /* : SelectorHandler[] */
	) /* : string */{
	    var processedStyleDefinitions /* : ProcessedStyleDefinitions */ = {
	        classNameBits: [],
	        definitionBits: []
	    };
	    // Mutates processedStyleDefinitions
	    processStyleDefinitions(styleDefinitions, processedStyleDefinitions);

	    // Break if there aren't any valid styles.
	    if (processedStyleDefinitions.classNameBits.length === 0) {
	        return "";
	    }

	    var className = undefined;
	    {
	        className = processedStyleDefinitions.classNameBits.join("-o_O-");
	    }

	    injectStyleOnce(className, '.' + className, processedStyleDefinitions.definitionBits, useImportant, selectorHandlers);

	    return className;
	};
	exports.injectAndGetClassName = injectAndGetClassName;
	});

	var inject$1 = unwrapExports(inject);
	var inject_1 = inject.injectStyleOnce;
	var inject_2 = inject.reset;
	var inject_3 = inject.startBuffering;
	var inject_4 = inject.flushToString;
	var inject_5 = inject.flushToStyleTag;
	var inject_6 = inject.getRenderedClassNames;
	var inject_7 = inject.addRenderedClassNames;
	var inject_8 = inject.injectAndGetClassName;

	var inject$2 = /*#__PURE__*/Object.freeze({
		default: inject$1,
		__moduleExports: inject,
		injectStyleOnce: inject_1,
		reset: inject_2,
		startBuffering: inject_3,
		flushToString: inject_4,
		flushToStyleTag: inject_5,
		getRenderedClassNames: inject_6,
		addRenderedClassNames: inject_7,
		injectAndGetClassName: inject_8
	});

	var _inject = ( inject$2 && inject$1 ) || inject$2;

	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





	/* ::
	import type { SelectorHandler } from './generate.js';
	export type SheetDefinition = { [id:string]: any };
	export type SheetDefinitions = SheetDefinition | SheetDefinition[];
	type RenderFunction = () => string;
	type Extension = {
	    selectorHandler: SelectorHandler
	};
	export type MaybeSheetDefinition = SheetDefinition | false | null | void
	*/

	var StyleSheet = {
	    create: function create(sheetDefinition /* : SheetDefinition */) {
	        return (0, _util.mapObj)(sheetDefinition, function (_ref) {
	            var _ref2 = _slicedToArray(_ref, 2);

	            var key = _ref2[0];
	            var val = _ref2[1];

	            var stringVal = JSON.stringify(val);
	            return [key, {
	                _len: stringVal.length,
	                _name: key + '_' + (0, _util.hashString)(stringVal),
	                _definition: val
	            }];
	        });
	    },

	    rehydrate: function rehydrate() {
	        var renderedClassNames /* : string[] */ = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

	        (0, _inject.addRenderedClassNames)(renderedClassNames);
	    }
	};

	/**
	 * Utilities for using Aphrodite server-side.
	 */
	var StyleSheetServer = {
	    renderStatic: function renderStatic(renderFunc /* : RenderFunction */) {
	        (0, _inject.reset)();
	        (0, _inject.startBuffering)();
	        var html = renderFunc();
	        var cssContent = (0, _inject.flushToString)();

	        return {
	            html: html,
	            css: {
	                content: cssContent,
	                renderedClassNames: (0, _inject.getRenderedClassNames)()
	            }
	        };
	    }
	};

	/**
	 * Utilities for using Aphrodite in tests.
	 *
	 * Not meant to be used in production.
	 */
	var StyleSheetTestUtils = {
	    /**
	     * Prevent styles from being injected into the DOM.
	     *
	     * This is useful in situations where you'd like to test rendering UI
	     * components which use Aphrodite without any of the side-effects of
	     * Aphrodite happening. Particularly useful for testing the output of
	     * components when you have no DOM, e.g. testing in Node without a fake DOM.
	     *
	     * Should be paired with a subsequent call to
	     * clearBufferAndResumeStyleInjection.
	     */
	    suppressStyleInjection: function suppressStyleInjection() {
	        (0, _inject.reset)();
	        (0, _inject.startBuffering)();
	    },

	    /**
	     * Opposite method of preventStyleInject.
	     */
	    clearBufferAndResumeStyleInjection: function clearBufferAndResumeStyleInjection() {
	        (0, _inject.reset)();
	    }
	};

	/**
	 * Generate the Aphrodite API exports, with given `selectorHandlers` and
	 * `useImportant` state.
	 */
	var makeExports = function makeExports(useImportant, /* : boolean */
	selectorHandlers /* : SelectorHandler[] */
	) {
	    return {
	        StyleSheet: _extends({}, StyleSheet, {

	            /**
	             * Returns a version of the exports of Aphrodite (i.e. an object
	             * with `css` and `StyleSheet` properties) which have some
	             * extensions included.
	             *
	             * @param {Array.<Object>} extensions: An array of extensions to
	             *     add to this instance of Aphrodite. Each object should have a
	             *     single property on it, defining which kind of extension to
	             *     add.
	             * @param {SelectorHandler} [extensions[].selectorHandler]: A
	             *     selector handler extension. See `defaultSelectorHandlers` in
	             *     generate.js.
	             *
	             * @returns {Object} An object containing the exports of the new
	             *     instance of Aphrodite.
	             */
	            extend: function extend(extensions /* : Extension[] */) {
	                var extensionSelectorHandlers = extensions
	                // Pull out extensions with a selectorHandler property
	                .map(function (extension) {
	                    return extension.selectorHandler;
	                })
	                // Remove nulls (i.e. extensions without a selectorHandler
	                // property).
	                .filter(function (handler) {
	                    return handler;
	                });

	                return makeExports(useImportant, selectorHandlers.concat(extensionSelectorHandlers));
	            }
	        }),

	        StyleSheetServer: StyleSheetServer,
	        StyleSheetTestUtils: StyleSheetTestUtils,

	        css: function css() /* : MaybeSheetDefinition[] */{
	            for (var _len = arguments.length, styleDefinitions = Array(_len), _key = 0; _key < _len; _key++) {
	                styleDefinitions[_key] = arguments[_key];
	            }

	            return (0, _inject.injectAndGetClassName)(useImportant, styleDefinitions, selectorHandlers);
	        }
	    };
	};

	var exports$1 = makeExports;

	var exports$2 = /*#__PURE__*/Object.freeze({
		default: exports$1,
		__moduleExports: exports$1
	});

	var _exports2 = ( exports$2 && exports$1 ) || exports$2;

	var lib = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', {
	    value: true
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





	var _exports3 = _interopRequireDefault(_exports2);

	var useImportant = true; // Add !important to all style definitions
	exports['default'] = (0, _exports3['default'])(useImportant, _generate.defaultSelectorHandlers);
	module.exports = exports['default'];
	});

	unwrapExports(lib);
	var lib_1 = lib.StyleSheet;
	var lib_2 = lib.css;

	const xhrOpenListeners = [];
	function addXhrOpenListener(cb) {
	    xhrOpenListeners.push(cb);
	}
	const realOpen = XMLHttpRequest.prototype.open;
	XMLHttpRequest.prototype.open = function (...args) {
	    const ret = realOpen.apply(this, args);
	    xhrOpenListeners.forEach(f => f(this));
	    return ret;
	};
	const fetchListeners = [];
	function addFetchListener(cb) {
	    fetchListeners.push(cb);
	}
	const realFetch = window.fetch;
	window.fetch = function (input, init) {
	    return new Promise(function (resolve, reject) {
	        realFetch(input, init).then(function (response) {
	            fetchListeners.forEach(f => f(response));
	            resolve(response);
	        }).catch(function (error) {
	            reject(error);
	        });
	    });
	};
	function fetchResult(id, options$$1) {
	    return new Promise((resolve, reject) => {
	        const req = new XMLHttpRequest;
	        req.addEventListener("load", () => {
	            const response = JSON.parse(req.responseText);
	            const root = response.root;
	            const name = root.name;
	            const [method, ...urlParts] = name.split(' ');
	            const url = new URL(urlParts.join(' '));
	            resolve({
	                id: response.id,
	                durationMs: root.duration_milliseconds,
	                method: method,
	                urlPath: url.pathname
	            });
	        });
	        req.open("GET", `${options$$1.path}results?id=${id}`);
	        // This forces rack to recognize this as an xhr
	        // See: https://apidock.com/rails/Rack/Request/xhr%3F
	        // req.setRequestHeader('HTTP_X_REQUESTED_WITH', 'XMLHttpRequest')
	        req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	        req.send();
	    });
	}
	function getOptions(script) {
	    const version = script.getAttribute('data-version');
	    const path = script.getAttribute('data-path');
	    const currentId = script.getAttribute('data-current-id');
	    const ids = (script.getAttribute('data-ids') || '').split(',');
	    const horizontalPosition = script.getAttribute('data-horizontal-position');
	    const verticalPosition = script.getAttribute('data-vertical-position');
	    const toggleShortcut = script.getAttribute('data-toggle-shortcut');
	    const collapseResults = script.getAttribute('data-collapse-results') === 'true';
	    const trivial = script.getAttribute('data-trivial') === 'true';
	    const children = script.getAttribute('data-children') === 'true';
	    const controls = script.getAttribute('data-controls') === 'true';
	    const authorized = script.getAttribute('data-authorized') === 'true';
	    const startHidden = script.getAttribute('data-start-hidden') === 'true';
	    const htmlContainer = script.getAttribute('data-html-container');
	    return {
	        ids: ids,
	        path: path,
	        version: version,
	        renderHorizontalPosition: horizontalPosition,
	        renderVerticalPosition: verticalPosition,
	        showTrivial: trivial,
	        showChildrenTime: children,
	        showControls: controls,
	        currentId: currentId,
	        authorized: authorized,
	        toggleShortcut: toggleShortcut,
	        startHidden: startHidden,
	        collapseResults: collapseResults,
	        htmlContainer: htmlContainer
	    };
	}
	class Details extends Component {
	    constructor() {
	        super(...arguments);
	        this.styles = lib_1.create({
	            row: {
	                width: 300,
	                height: 24,
	                fontSize: '11px',
	                lineHeight: '24px',
	                color: '#F2F2F2',
	                fontFamily: 'Courier, monospace',
	                display: 'flex',
	                pointerEvents: 'auto',
	                ':hover': {
	                    backgroundColor: '#828282'
	                }
	            },
	            oddRow: {
	                backgroundColor: '#222222'
	            },
	            evenRow: {
	                backgroundColor: '#050505'
	            },
	            duration: {
	                width: 60,
	                display: 'block',
	                backgroundColor: 'rgba(255, 255, 255, 0.1)',
	                paddingRight: 6,
	                textAlign: 'right'
	            },
	            url: {
	                display: 'block',
	                textOverflow: 'ellipsis',
	                overflow: 'hidden',
	                whiteSpace: 'nowrap',
	                paddingLeft: 6,
	                flex: 1
	            },
	            bold: {
	                fontWeight: 'bold'
	            }
	        });
	        this.renderResult = (result, index) => {
	            const { options: options$$1 } = this.props;
	            const { protocol, host } = window.location;
	            const profileURL = `${protocol}//${host}/${options$$1.path}profile?id=${result.id}`;
	            const title = result.urlPath;
	            const url = `${options$$1.path}speedscope/index.html#profileURL=${encodeURIComponent(profileURL)}&title=${encodeURIComponent(title)}`;
	            return h("a", { href: url, target: '_blank', className: lib_2(this.styles.row, index % 2 === 0 ? this.styles.evenRow : this.styles.oddRow) },
	                h("span", { className: lib_2(this.styles.duration) },
	                    h("span", { className: lib_2(this.styles.bold) }, Math.round(result.durationMs)),
	                    "ms"),
	                h("span", { className: lib_2(this.styles.url) },
	                    h("span", { className: lib_2(this.styles.bold) }, result.method),
	                    ' ',
	                    result.urlPath));
	        };
	    }
	    render() {
	        return h("div", null, this.props.results.map(this.renderResult));
	    }
	}
	class EntryPoint extends Component {
	    constructor() {
	        super(...arguments);
	        this.styles = lib_1.create({
	            entryPoint: {
	                width: 102,
	                height: 24,
	                fontFamily: 'Courier, monospace',
	                fontSize: '11px',
	                lineHeight: '24px',
	                backgroundColor: '#050505',
	                color: '#E0E0E0',
	                textAlign: 'center',
	                userSelect: 'none',
	                pointerEvents: 'auto',
	                ':hover': {
	                    backgroundColor: '#828282'
	                }
	            },
	            bold: {
	                fontWeight: 'bold'
	            }
	        });
	    }
	    render() {
	        const max = Math.round(Math.max(...(this.props.results.map(res => res.durationMs))));
	        return h("div", { className: lib_2(this.styles.entryPoint) },
	            h("span", { className: lib_2(this.styles.bold) }, max),
	            "ms max/",
	            this.props.results.length);
	    }
	}
	class MiniProfiler extends Component {
	    constructor() {
	        super();
	        this.resultById = Object.create(null);
	        this.fetchResultOnce = (id) => {
	            if (!this.resultById[id]) {
	                this.resultById[id] = fetchResult(id, this.options).then((result) => {
	                    this.setState({ results: [...this.state.results, result] });
	                    return result;
	                });
	            }
	            return this.resultById[id];
	        };
	        this.styles = lib_1.create({
	            container: {
	                zIndex: Number.MAX_SAFE_INTEGER - 10,
	                width: '100vw',
	                height: '100vh',
	                position: 'fixed',
	                top: 0,
	                left: 0,
	                pointerEvents: 'none',
	                display: 'flex',
	                justifyContent: 'flex-end',
	                alignItems: 'flex-end',
	                flexDirection: 'column'
	            },
	            hoverArea: {
	                display: 'flex',
	                justifyContent: 'flex-end',
	                alignItems: 'flex-end',
	                flexDirection: 'column',
	                pointerEvents: 'auto',
	                ':hover .mini-profiler-details': {
	                    display: 'block'
	                }
	            }
	        });
	        const script = document.getElementById('mini-profiler');
	        if (!script || !script.getAttribute)
	            return;
	        this.options = getOptions(script);
	        this.state = {
	            results: []
	        };
	    }
	    componentDidMount() {
	        addFetchListener((response) => {
	            console.log("fetch listener", response);
	            if (response.url.indexOf(this.options.path) !== -1)
	                return;
	            // Ignore cross domain requests
	            if (!response.url.startsWith(`${window.location.protocol}//${window.location.host}`))
	                return;
	            for (var pair of response.headers.entries()) {
	                if (pair[0] && (pair[0].toLowerCase() == 'x-miniprofiler-ids')) {
	                    const ids = JSON.parse(pair[1]);
	                    ids.forEach(this.fetchResultOnce);
	                }
	            }
	        });
	        addXhrOpenListener((xhr) => {
	            xhr.addEventListener('load', () => {
	                if (xhr.responseURL.indexOf(this.options.path) !== -1)
	                    return;
	                if (!xhr.responseURL.startsWith(`${window.location.protocol}//${window.location.host}`)) {
	                    // Ignore cross domain requests
	                    return;
	                }
	                const ids = xhr.getResponseHeader('X-MiniProfiler-Ids');
	                if (ids) {
	                    const idList = JSON.parse(ids);
	                    idList.forEach(this.fetchResultOnce);
	                }
	            });
	        });
	        this.fetchResultOnce(this.options.currentId);
	    }
	    render() {
	        const { results } = this.state;
	        if (results.length === 0) {
	            return null;
	        }
	        return h("div", { className: lib_2(this.styles.container) },
	            h("div", { className: lib_2(this.styles.hoverArea) },
	                h("div", { style: { display: 'none' }, className: 'mini-profiler-details' },
	                    h(Details, { results: results, options: this.options })),
	                h(EntryPoint, { results: results, options: this.options })));
	    }
	}
	render(h(MiniProfiler, null), document.body);

}());
